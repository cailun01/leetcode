/* 1312 让字符串成为回文串的最少插入次数
给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。

请你返回让 s 成为回文串的 最少操作次数 。

「回文串」是正读和反读都相同的字符串。

示例 1：

输入：s = "zzazz"
输出：0
解释：字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。

示例 2：
输入：s = "mbadm"
输出：2
解释：字符串可变为 "mbdadbm" 或者 "mdbabdm" 。

示例 3：
输入：s = "leetcode"
输出：5
解释：插入 5 个字符后字符串变为 "leetcodocteel" 。

示例 4：
输入：s = "g"
输出：0

示例 5：
输入：s = "no"
输出：1
*/

/* 
回文问题一般都是从字符串的中间向两端扩散，构造回文串也是类似的。
定义一个二维的dp数组，dp[i][j]的定义如下：
对字符串s[i..j]，最少需要进行dp[i][j]次插入才能变成回文串。

我们想求整个s的最少插入次数，根据这个定义，也就是想求dp[0][n-1]的大小（n为s的长度）。

base case: 当i == j时dp[i][j] = 0，因为当i == j时s[i..j]就是一个字符，本身就是回文串，所以不需要进行任何插入操作。

如果s[i] == s[j]，我们不需要进行任何插入，只要知道如何把s[i+1..j-1]变成回文串即可。
如果s[i] != s[j]，
步骤一，做选择，先将s[i..j-1]或者s[i+1..j]其中之一变成回文串。
步骤二，根据步骤一的选择，将s[i..j]变成回文。
如果你在步骤一中选择把s[i+1..j]变成回文串，那么在s[i+1..j]右边插入一个字符s[i]一定可以将s[i..j]变成回文；
同理，如果在步骤一中选择把s[i..j-1]变成回文串，在s[i..j-1]左边插入一个字符s[j]一定可以将s[i..j]变成回文。
步骤一中选择插入次数小的，步骤二必然要执行一次插入。
*/

class Solution {
public:
  int minInsertions(string s) {
    int n = s.size();
    // 定义：对 s[i..j]，最少需要插入 dp[i][j] 次才能变成回文
    vector<vector<int>> dp(n, vector<int>(n, 0));
    // base case：i == j 时 dp[i][j] = 0，单个字符本身就是回文
    // dp 数组已经全部初始化为 0，base case 已初始化

    /* 状态转移方程中dp[i][j]和dp[i+1][j]，dp[i][j-1]，dp[i+1][j-1]三个状态有关，
       为了保证每次计算dp[i][j]时，这三个状态都已经被计算，我们一般选择从下向上，从左到右遍历dp数组
    */

    // 从下向上遍历
    for (int i = n - 2; i >= 0; i--) {
      // 从左向右遍历
      for (int j = i + 1; j < n; j++) {
        // 根据 s[i] 和 s[j] 进行状态转移
        if (s[i] == s[j]) {
          dp[i][j] = dp[i + 1][j - 1];
        } else {
          /* 步骤一选择代价较小的 min(dp[i + 1][j], dp[i][j - 1])
	           步骤二必然要进行一次插入 */
          dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
        }
      }
    }
    // 根据 dp 数组的定义，题目要求的答案
    return dp[0][n - 1];
  }
};